# django

## modelos

Os modeloss são criados no Django para que possamos fazer com que os dados da nossa aplicação sejam salvos em um banco de dados.

Para fazer isso, vamos alterar o arquivo `/meu_site/playstation/models.py`. Esse arquivo é o responsável por ter a classe que vai controlar os dados daquele aplicativo.

Veja como vai ficar a nossa classe, usando como modelo uma estrutura parecida com a que fizemos no arquivo `/utils/versoes/fabrica.py` :

```python
# /meu_site/playstation/modelos.py
from django.db import models

# Create your models here.
class Versao(models.Model):
    nome = models.CharField(max_length=128)
    sigla = models.CharField(max_length=4)
    ano = models.IntegerField()
    link = models.SlugField()
    descricao = models.CharField(max_length=256)
    lancamento = models.DateField()
    eh_publicado = models.BooleanField(default=False)
    foto = models.ImageField(upload_to='img/%Y/%m/%d')
```

Por enquanto, nosso código da classe ficará assim.

Sobre o código acima :
- o campo slug será usado para criarmos a url com base em algum texto;
- vários campos são semelhantes aos usados no banco de dados;

Agora, finalmente, vamos nos livrar daquela mensagem que sempre vemos ao executarmos o servidor!

```bash
(.venv) meu_site> python manage.py runserver
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).

You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
October 18, 2024 - 16:17:14
Django version 5.1.2, using settings 'consoles.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.

```

Para isso, temos que executar o comando abaixo :

```bash
(.venv) meu_site> python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK
```

Esse comando, vai preparar o banco de dados para receber as nossas classes.

Agora, vamos executar outro comando para que as nossas classes sejam usadas no banco de dados :

```bash
(.venv) meu_site> python manage.py makemigrations
Migrations for 'playstation':
  playstation/migrations/0001_initial.py
    + Create model Versao

(.venv) meu_site> |
```

Esse comando vai gerar um arquivo que vai ficar salvo na pasta especificada acima.

O arquivo Python contém todo o código que será usado pelo Django para criar as nossas tabelas no banco de dados.

```python
# Generated by Django 5.1.2 on 2024-10-18 16:18

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Versao',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nome', models.CharField(max_length=128)),
                ('sigla', models.CharField(max_length=4)),
                ('ano', models.IntegerField()),
                ('link', models.SlugField()),
                ('descricao', models.CharField(max_length=256)),
                ('lancamento', models.DateField()),
                ('eh_publicado', models.BooleanField(default=False)),
                ('foto', models.ImageField(upload_to='img/%Y/%m/%d')),
            ],
        ),
    ]

```

Repare no nome do arquivo. Esse nome e o todo o código dentro foi gerado automaticamente. Eles ***`NUNCA`*** devem ser alterados.

Agora, executaremos novamente o comando abaixo. Ele vai realizar a criação das tabelas para nosso aplicativo.

```bash
(.venv) meu_site> python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, playstation, sessions
Running migrations:
  Applying playstation.0001_initial... OK

(.venv) meu_site> |
```

Agora, quando nossos modelos criados serão gerados dentro do arquivo de banco de dados `db.sqlite3`.

**`IMPORTANTE`** : sempre que qualquer alteração for feita nos arquivos `models.py` de qualquer aplicativo, somos obrigados a reexecutar os dois comandos :
- python manage.py makemigrations
- python manage.py migrate

## inserindo dados

Agora que temos as tabelas criadas, podemos inserir dados nelas. Para isso, temos que acessar a página administrativa do Django através da url `http://127.0.0.1:8000/admin` (ou `http://localhost:8000/admin`).

O problema é que ainda não temos como acessar, pois ainda não temos um usuário com perfil administrativo.

Para resolver isso, temos que ir ao terminal e executar o comando abaixo :

```bash
(.venv) meu_site> python manage.py createsuperuser
Username (leave blank to use 'guto'): admin
Email address: admin@admin.com
Password:
Password (again):
The password is too similar to the username.
This password is too short. It must contain at least 8 characters.
This password is too common.
Bypass password validation and create user anyway? [y/N]: y
Superuser created successfully.

(.venv) meu_site> |
```

O comando acima, chamado através do arquivo `manage.py`, vai executar um terminal interativo com os seguintes passos :
- primeiro, vai ser pedido para criar um nome de usuário;
- depois, vai ser pedido para inserir um e-mail;
    - como estamos em um ambiente de desenvolvimento, não tem problema usarmos um e-mail falso;
    - mas em um ambiente de produção, tem que ser usado um e-mail válido, até porque é ele quem será usado para recuperar a conta.
- por fim, temos que escolher uma senha para o usuário;
    - para essa senha, é fortemente recomendado seguir as recomendações de segurança para a criação dela (destacadas em texto vermelho).
    - novamente, sendo um ambiente de ensino, não tem problema usarmos uma senha fraca e de mais fácil memorização;

Agora, já podemos entrar com esse login na tela administrativa.

Explorando os links da tela de início, podemos ver páginas para grupos e usuários. Lá, como os nomes sugerem, podemos adicionar grupos e usuários. Também, na página de usuário podemos ver o usuário que acabamos de criar no terminal.

Depois de explorar as páginas, podemos ver que estão faltando os modelos que criamos para nosso projeto. Nesse caso, as versões de lançamento da nossa linguagem de programação.

Para eles aparecerem lá, temos que alterar o arquivo `/meu_site/playstation/admin.py` importando o arquivo `/meu_site/playstation/models.py`, para então importar a nossa classe criada anteriormente. Veja como ele ficará :

```python
# /meu_site/playstation/admin.py
from django.contrib import admin
from . import models

# Register your models here.
class VersaoAdmin(admin.ModelAdmin):
    ...

admin.site.register(models.Versao, VersaoAdmin)
```

Agora, quando recarregarmos a página, veremos um novo tópico com o nomeo do nosso aplicativo e a classe que criamos. Caso não apareça, experimente deslogar e logar novamente. Ali é possível listar os objetos criados e adicionar novos.

Experimente você alterar e adicionar algum objeto para sua classe. Para salvar tudo, basta irmos no botão ao final da página escrito **SAVE**.

Se reparar na notificação (e até no nome do objeto), aparece um nome bem esquisito. Isso acontece porque a classe `Versao` não tem um método mágico __str__ definido. Para arrumar isso é bem simples. Basta adicionarmos o método na classe.

```python
# /meu_site/playstation/modelos.py
from django.db import models

# Create your models here.
class Versao(models.Model):
    nome = models.CharField(max_length=128)
    sigla = models.CharField(max_length=4)
    ano = models.IntegerField()
    link = models.SlugField()
    descricao = models.CharField(max_length=256)
    lancamento = models.DateField()
    eh_publicado = models.BooleanField(default=False)
    foto = models.ImageField(upload_to='img/%Y/%m/%d')

    def __str__(self):
        return self.nome
```

Agora, ao salvarmos e recarregarmos a página, será apresentado o nome correto do objeto.

Finalente, podemos adicionar, alterar, atualizar e excluir os dados para nosso site sem a necessidade de usar a biblioteca Faker do Python.

Se inspecionarmos qualquer versão cadastrada, podemos ver que é possível alterar seus dados e há também um caminho onde a imagem carregada foi armazenada. Ao observarmos a pasta do projeto (pelo `VS Code`), veremos a pasta criada para armazenar essa imagem. Ela e todas duas subpastas. Aqui, elas foram divididas em **ano**, **mês** e **dia** :

```
 meu_site
├──  .venv
├──  .vscode
├──  consoles
├──  img
│  └──  2024
│     └──  10
│        └──  21
│           └──  frances.jpg
├──  playstation
├──  static
├──  utilidades
├──  xbox
├──  manage.py
├──  backup.sh
├──  restore.sh
└──  db.sqlite3
```

Embora a imagem tenha sido carregada com sucesso, se clicarmos no link dela seremos encaminhado para uma página inexistente. Isso acontece porque não registramos essa pasta de imagens nas configurações do nosso projeto, em `/meu_site/consoles/settings.py`. Para arrumar isso, temos que adicionar o caminho da pasta das imagens no nosso arquivo de configurações (mais ou menos como foi feito com a pasta dos arquivos estáticos) :

```python
# /meu_site/consoles/settings.py
...
STATIC_ROOT = BASE_DIR / 'static'

MEDIA_URL = '/img/'
MEDIA_ROOT = BASE_DIR / 'midia'

# Default primary key field type
...
```

Ainda é preciso alterar mais um lugar. É preciso alterar também o arquivo `/meu_site/consoles/urls.py` :

```python
# /meu_site/consoles/urls.py
from django.contrib import admin
from django.urls import path,include
from django.conf.urls.static import static  # <!----
from django.conf import settings  # <!----

urlpatterns = [
    path('admin/', admin.site.urls),
    path('ps/', include('playstation.urls')),
    path('xb/', include('xbox.urls')),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)  # <!----
```

Agora, finalmente, nossa imagem será carregada.

## alterando o idioma de exibição

Provavelmente você já reparou, mas toda a interface administrativa do Django está em inglês.

Para alterar o idioma, temos que ir no arquivo `/meu_site/consoles/settings.py` e alterar a variável `LANGUAGE_CODE` para o idioma brasileiro.

```python
# /meu_site/consoles/settings.py
...
# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'pt-br'  # <!----

TIME_ZONE = 'UTC'

USE_I18N = True
...
```

Agora, nossa interface administrativa ficará toda em português.

## carregando dados

Quando salvamos os dados no banco de dados usando a página de administração, o Django automaticamente tem acesso a eles. Para acessar esses dados, usamos um gerenciador específico do Django.

Contudo, nossas páginas não tem esse acesso. Para acessá-los, temos que importar o módulo `/meu_site/playstation/models.py` para o módulo `/meu_site/playstation/views.py` e então chamar as características herdadas da classe `Model` :

```python
# /meu_site/playstation/views.py
from django.shortcuts import render
from utilidades.versoes.fabrica import cria_versao
from . import models  # <!----

...

def view_versoes(request):
    dados = models.Versao.objects.all()  # <!----

    print(f'{dados = }')  # <!----

    dados = {'versoes': DADOS}
    return render(request, 'playstation/paginas/versoes.html', context=dados)

def view_versao(request, id):
...
```

Quando carregarmos a página da função, vamos ver o seguinte no terminal :

```bash
/home/guto/meu_site/consoles/urls.py changed, reloading.
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).
October 21, 2024 - 19:09:44
Django version 5.1.2, using settings 'consoles.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.

dados = <QuerySet [<Versao: PlayStation 1>]>
[21/Oct/2024 19:09:51] "GET /ps/versoes/ HTTP/1.1" 200 1104
|
```

Isso nos mostra que estamos carregando os dados do banco de dados.

O que está sendo mostrado é uma QuerySet. Ela é um objeto do Django que fica responsável por buscar os dados no banco de dados e retornar para a aplicação.

### comandos

O principal método para buscar todos os dados de uma tabela é o `.objects.all()` :

```python
# /meu_site/playstation/views.py
...
def view_versoes(request):
    dados = models.Versao.objects.all()  # <!----
...
```

Que, como mencionado anteriormente, vai retornar uma lista do conteúdo da tabela :

```bash
dados = <QuerySet [<Versao: PlayStation 1>, <Versao: PlayStation 2>]>  <!----
```

Há diferentes formas de retornar os resultados, como ordenar por algum atributo da classe (que também é o nome do campo na tabela) :

```python
# /meu_site/playstation/views.py
...
def view_versoes(request):
    dados = models.Versao.objects.all()
    print(f'dados -> {versoes}')
    print(f'dados.order_by("titulo") -> {dados.order_by("titulo")}')  # <!----
    print(f'dados.order_by("-titulo") -> {dados.order_by("-titulo")}')  # <!----
...
```

O método `.order_by()` é usado para ordenarmos os resultados buscados no banco de dados. O padrão é ordenar pela chave primária em ordem crescente.

Abaixo, temos a busca ordenando pelo título usando a ordem ascendente e a ordem descendente, que é representada pelo símbolo `–` (sinal de menos) junto do nome do atributo :

```bash
dados.order_by("titulo") -> <QuerySet [<Versao: PlayStation 1>, <Versao: PlayStation 2>]>
dados.order_by("-titulo") -> <QuerySet [<Versao: PlayStation 2>, <Versao: PlayStation 1>]>
```

Também podemos combinar mais de um campo de ordenação :

```python
# /meu_site/playstation/views.py
...
def view_versoes(request):
    dados = models.Versao.objects.all()
    print(f'dados -> {versoes}')
    print(f'dados.order_by("titulo,id") -> {dados.order_by("titulo,id")}')  # <!----
...
```
Acima, estamos ordenando primeiro pelo título em ordem crescente e, se houver mais de um registro com o mesmo nome, é ordenado pelo id em ordem crescente.

Como o que está sendo retornado uma lista de objetos do tipo Versao, podemos iterar por ela usando o loop for :

```python
# /meu_site/playstation/views.py
...
def view_versoes(request):
    dados = models.Versao.objects.all()

    for versao in dados:
        print(f'{versao = }')
        print(f'{versao.__dict__ = }')
...
```

Se tratando de um objeto, acessamos seus valores do atributos usando a notação do ponto entre o objeto e seu atributo.

Também podemos usar o método `.first()` para retornar apenas o primeiro elemento daquela busca :

```python
# /meu_site/playstation/views.py
...
def view_versoes(request):
    dados = models.Versao.objects.all()

    print(f'{dados.first() = }')
...
```

O elemento retornado, vai vir na forma do objeto.

Se quiser, podemos realizar o ordenamento da lista usando o `.order_by()` e usar o `–` para deixar a lista em ordem reversa e então usar o `first()` para recuperar o último elemento da lista.

Há uma forma de buscar por todos os campos e tipos do objeto buscado no banco de dados. Usando o `_meta.get_field()` é nos retornado uma tupla com todos os dados :

```python
# /meu_site/playstation/views.py
...
def view_versoes(request):
    dados = models.Versao.objects.all()

    print(f'{dados[0]._meta.get_fields() = }')
...
```

Depois de buscados os dados no banco de dados com o método `all()`, podemos realizar um filtro do que foi buscado.

Por exemplo, podemos filtrar todos as versões que têm valor `True` no campo `eh_publicado` usando o método `.filter()` :

```python
# /meu_site/playstation/views.py
...
def view_versoes(request):
    dados = models.Versao.objects.filter(eh_publicaco=True)

    print(f'{dados[0]._meta.get_fields() = }')
...
```

Há também outra forma de realizar esse filtro usando o `.get()` :

```python
# /meu_site/playstation/views.py
...
def view_versoes(request):
    dados = models.Versao.objects.get(eh_publicaco=True)

    print(f'{dados[0]._meta.get_fields() = }')
...
```

Há uma grande diferença entre os dois métodos. O `.filter()` retorna uma lista dos itens filtrados, enquanto que o `.get()` retorna o objeto em si. Tem que ter o cuidado na hora de usar um ou outro, já que, se a busca não encontrar qualquer registro no `.filter()`, vai retornar uma lista vazia, já o `.get()` vai gerar um erro.

Mais sobre a `QuerySet` pode ser encontrado na [QuerySet API reference](https://docs.djangoproject.com/pt-br/5.1/ref/models/querysets/).

## exercícios - parte 9

<details>
<summary>Lista de Exercícios</summary>

1. Pratique o que foi visto.
1. Use o que foi aprendido em aula e aplique nos seus projetos (etapa não obrigatória).

</details>
